// first index.html is loaded. Then cz of 'cli' all the required scripts are loaded, that includes main.bundle.// js. In that 'main.ts' is executed first. It bootstraps/starts the applictaion.
// localhost:4200
// classname: PascalCase
// propertyname: CamelCase
//class is not a component unless it has a component decorator
// *ngIf *ngFor : structural directives
// for..of vs for..in [Ex: let names=['abc, 'def, 'ghi']]
// for..of => iterates over iterable objects such as an array. (result: abc, def, ghi)
// for..in => iterates over properties of an object. (result: 0, 1, 2)
// property binding, interpolation => One-way binding
// <img [src] = 'product.imageUrl'> or <img src={{product.imageUrl}}>
// <button (click)='toggaleImage()'> => Event Binding
// {{product.price | currency:'USD':true:'1.2-2'}} => atleast 1 number to the left of decimel and 
// max&min 2 to the right of decimal
//adv of typescript => every property has a type, every method and method parameter has a return type(void),
// ES2015 do not support interfaces but typescript does
// Component Lifecycle Hooks => OnInit, OnChange, OnDestroy
// OnInit interface defines ngOnInit() method
// to use the componnet relative path for the template and stylesheet Urls use the 'module.id'
// ngOnChanges only occurs to input changes
// if a nested comp wants to use the input of main comp, it has to expose a method to receive the 
// input =>  @Input() --> decorator
// only time we can pass the nested component's property binding is when it is given as a decorator
// only way to pass data back from nested comp to parent comp is thru an event --> @Output()
// TypeScript supports Generics
//properties decorated with Input or Output decorators can be considered as the Public API of the
// nestable component. Everything else in the comp is encapsulated and is only accessible to the
// comp's template and the class

//if a service has an injectable dependency of its own then we use the decorator @Injectable()
// service is an ordinary cls until we register it with an angular injector
// that injector provides an instance to the cls that has a dependency
// '_' to denote its a private variable
// shud subscribe to the observable returned from the service
// <any> --> casting data type, means casting it to any data type

// html5 supports url rewriting so no need of # in url. url rewriting is configured on the server 
// side aand depends on server
// RouterModule.forRoot: registers the router service provider, declares the router directives and exposes 
// the but forChild dont register router service provider
// configured routes
// <router-outlet></router-outlet> is placed in the host comp's view(app.component.ts)
// To route or to nest ????????????

//sometimes we have to route using parameters (/:placeholder)
// we use snapchat approach if we dont expect the url to change, else use observableapproach.
// 'let':  new in ES2016 and defines a block scoped variable
// '+' is a JS shortcut to convert the parameter string into a numeric ID
// Use Route Gaurds => To prevent access to a route, to confirm navigation away from a route, to preload data
// for a route

//import are not inherited. Importing a module does not provide access to its imported modules
// to do that shud re-export the module
// cant import [BrowserModule] into ProductModule(Feature Module), it shud only be imported into app's root 
// module. To get that import the CommonModule (Browser module itselft imports and exports the CommonModule)
// ngFor, ngIf --> BrowserModule
// ngModule --> FormsModule
// Finally, import ProductModule into AppModule that extends AppModule's features

// Jit --> Just in Time
// AoT --> Ahead of Time